<qcm>
    			<code>var x = 1;
if (true) {
  var x = 2;
}
console.log(x);</code>
    			<question>la console affichera </question>
    			<choix>1</choix>
    			<choix correct>2</choix>
                <reponse>Les variables déclarées avec le mot clé <code>var</code> ont une portée globale (ou locale à l'intérieur d'une fonction), mais
                pas une portée de bloc. La deuxième déclaration de <code>x</code> écrase donc la première.</reponse>
    		</qcm>

    		<qcm>
    			<code>let x = 1;
if (true) {
  let x = 2;
}
console.log(x);</code>
    			<question>la console affichera </question>
    			<choix correct>1</choix>
    			<choix>2</choix>
                <reponse>Le mot clé <code>let</code> permet une portée de bloc. En sortant du bloc, la variable x égale à 2 n'existe plus.</reponse>
    		</qcm>

    		<qcm>
    			<code>if (true) {
	console.log(1);
} elseif (true) {
	console.log(2);
}</code>
    			<question>la console affichera</question>
    			<choix correct>Error</choix>
    			<choix>1</choix>
    			<choix>1, 2</choix>
                <reponse><code>elseif</code>n'est pas un mot clé en javascript. Il faut juste séparer le <code>else</code> du <code>if</code>.</reponse>
    		</qcm>

        <qcm>
          <code>let x;
if (!x) console.log("falsy value");</code>
          <question>la console affichera le message</question>
          <choix correct>oui</choix>
          <choix>non</choix>
          <reponse><code>x</code> a la valeur <code>undefined</code>, qui est équivalente à <code>false</code>.</reponse>
        </qcm>

        <qcm>
          <code>let x = null;
if (!x) console.log("falsy value");</code>
          <question>la console affichera le message</question>
          <choix correct>oui</choix>
          <choix>non</choix>
          <reponse><code>null</code> est une valeur équivalente à <code>false</code></reponse>
        </qcm>

        <qcm>
          <code>let x = 0;
if (!x) console.log("falsy value");</code>
          <question>la console affichera le message</question>
          <choix correct>oui</choix>
          <choix>non</choix>
          <reponse><code>0</code> est une valeur équivalente à <code>false</code> (ce qui est source de pièges)</reponse>
        </qcm>

        <qcm>
          <code>let x = -1;
if (!x) console.log("falsy value");</code>
          <question>la console affichera le message</question>
          <choix>oui</choix>
          <choix correct>non</choix>
          <reponse>Tout nombre différent de 0 est équivalent à <code>true</code></reponse>
        </qcm>

        <qcm>
          <code>let x = "";
if (!x) console.log("falsy value");</code>
          <question>la console affichera le message</question>
          <choix correct>oui</choix>
          <choix>non</choix>
          <reponse>Une chaîne vide est équivalente à <code>false</code></reponse>
        </qcm>

        <qcm>
          <code>let x = "0";
if (!x) console.log("falsy value");</code>
          <question>la console affichera le message</question>
          <choix>oui</choix>
          <choix correct>non</choix>
          <reponse>Toute chaîne non vide est équivalente à <code>true</code></reponse>
        </qcm>

        <qcm>
          <code>let x = {};
if (!x) console.log("falsy value");</code>
          <question>la console affichera le message</question>
          <choix>oui</choix>
          <choix correct>non</choix>
          <reponse>Tout objet est équivalent à <code>true</code></reponse>
        </qcm>

        <qcm>
          <code>let x = [];
if (!x) console.log("falsy value");</code>
          <question>la console affichera le message</question>
          <choix>oui</choix>
          <choix correct>non</choix>
          <reponse>Tout objet (dont les tableaux) est équivalent à <code>true</code></reponse>
        </qcm>

    		<qcm>
    			<code>let test = true;
console.log( test ? "toto" : "tata" );</code>
    			<question>la console affichera</question>
    			<choix>SyntaxError</choix>
    			<choix correct>"toto"</choix>
    			<choix>"tata"</choix>
                <reponse>C'est l'opérateur conditionnel ternaire : si la condition est vraie, c'est la première expression qui est renvoyée</reponse>
    		</qcm>

    		<qcm>
    			<code>let x = 1;
let y = 2;
let toto = x === y ? "toto" : "tata";</code>
    			<question>la variable toto vaut</question>
    			<choix>SyntaxError</choix>
    			<choix>"toto"</choix>
    			<choix correct>"tata"</choix>
                <reponse>La condition est fausse, donc c'est la deuxième expression qui est renvoyée.<br/>
                Les parenthèses sont vivement conseillées pour clarifier l'écriture.</reponse>
    		</qcm>

    		<qcm>
    			<code>let test = false;
console[ test ? "log" : "error" ]("coucou");</code>
    			<question>ce code provoque </question>
    			<choix>une erreur de syntaxe</choix>
    			<choix>un log de "coucou" dans la console</choix>
    			<choix correct>un log d'erreur de "coucou" dans la console</choix>
                <reponse>La condition est fausse, donc l'opérateur conditionnel ternaire renvoie "error".<br/>
                Ce qui revient à écrire : <code>console["error"]("coucou")</code><br/>
                Ce qui est la même chose que : <code>console.error("coucou")</code></reponse>
    		</qcm>

    		<qcm>
    			<code>let test = 2;
let str;
switch(test) {
	case 1 : str = "tata";
	case 2 : str = "toto";
	case 3 : str = "titi";
	default : str = "tutu";
}

str;</code>
    			<question>str vaut </question>
    			<choix>"tata"</choix>
    			<choix>"toto"</choix>
    			<choix>"titi"</choix>
    			<choix correct>"tutu"</choix>
                <reponse>Si on oublie l'instruction <code>break</code> en fin de cas, tout le reste du code est éxécuté.</reponse>
    		</qcm>

    		<!-- <qcm>
    			<code>let test = null;
switch(test) {
	case false : console.log("false"); break;
	case undefined : console.log("undefined"); break;
	case null : console.log("null"); break;
}</code>
    			<question>la console affichera </question>
    			<choix>"false"</choix>
    			<choix>"undefined"</choix>
    			<choix correct>"null"</choix>
                <reponse>C'est l'égalité stricte qui est testée.</reponse>
    		</qcm> -->

    		<qcm>
          <code>for (var i=0;i&lt;5;i++) { }

i;</code>
    			<question>la variable i vaut</question>
    			<choix>undefined</choix>
    			<choix>ReferenceError : i is not defined</choix>
    			<choix>4</choix>
    			<choix correct>5</choix>
                <reponse>La portée de <code>i</code> est globale.<br/>
                Il y a incrémentation de <code>i</code> jusqu'à ce que la condition ne soit plus vraie.<br/>
                Celà se produit quand <code>i</code> est égal à 5.
                </reponse>
    		</qcm>

            <qcm>
    			<code>for (let i=0;i<5;i++) { }
i;</code>
    			<question>la variable i vaut</question>
    			<choix>undefined</choix>
    			<choix correct>ReferenceError : i is not defined</choix>
    			<choix>4</choix>
    			<choix correct>5</choix>
                <reponse>L'instruction <code>let</code> donne une portée de bloc à la variable <code>i</code></reponse>
    		</qcm>

    		<!-- <qcm>
    			<code>let tab = ["toto","tata","titi"];
let i = tab.length;
while(i--) console.log(tab[i]);</code>
    			<question>la console affichera</question>
    			<choix>"toto", "tata", "titi"</choix>
    			<choix>undefined, "titi", "tata", "toto"</choix>
    			<choix correct>"titi", "tata", "toto"</choix>
    			<choix>undefined, "titi", "tata", "toto", undefined, undefined, ... (boucle infinie)</choix>
    			<choix>"titi", "tata", "toto", undefined, undefined, ... (boucle infinie)</choix>
                <reponse>On décrémente <code>i</code> et on affiche tab[i].<br/>
                Au premier passage, on affiche donc le dernier élément du tableau.<br/>
                Lorsque <code>i</code> est égal à 1, <code>i--</code> renvoie <code>1</code> mais <code>i</code> vaut alors 0, la première valeur du tableau est affichée.<br/>
                Au tour suivant, <code>i</code> est égal à <code>0</code>, <code>i--</code> renvoie <code>0</code> donc la condition est fausse.</reponse>
    		</qcm> -->

    		<qcm>
    			<code>let angeGaby = { nom : "Gabriel", age : null, sexe : null };

for (let n in angeGaby) console.log(angeGaby[n]);</code>
    			<question>la console affichera</question>
    			<choix>"nom", "age", "sexe"</choix>
    			<choix>"nom"</choix>
    			<choix>"Gabriel"</choix>
    			<choix correct>"Gabriel", null, null</choix>
                <reponse><code>n</code> itère sur les noms de propriétés. <code>angeGaby[n]</code> est donc la valeur de la propriété correspondante.</reponse>
        </qcm>

        <!-- <qcm>
    			<code>let angeGaby = { nom : "Gabriel", age : null, sexe : null };

for (let value of angeGaby) console.log(value);</code>
          <question>la console affichera</question>
          <choix>"nom", "age", "sexe"</choix>
    			<choix>"Gabriel", null, null</choix>
    			<choix correct>TypeError: angeGaby is not iterable</choix>
          <reponse><code>for...of</code> ne fonctionne qu'avec les objets itérables (tableaux, chaînes, listes)</reponse>
        </qcm> -->

    		<qcm>
    			<code>try {
  alert(tata);
}
catch(e) {
  alert("toto");
}</code>
    			<question>ce code affiche</question>
    			<choix>tata</choix>
    			<choix correct>"toto"</choix>
    			<choix>tata puis "toto"</choix>
                <reponse><code>tata</code> est indéfini. Une exception est donc levée, elle est interceptée par le bloc <code>catch</code>.
                C'est donc la chaîne "toto" qui va s'afficher.</reponse>
    		</qcm>

    		<qcm>
    			<code>let i=0;

setTimeout(() => i++, 1000);

console.log(i);</code>
    			<question>la console affiche</question>
    			<choix correct>0</choix>
    			<choix>1</choix>
                <reponse><code>i</code> est incrémenté 1 seconde plus tard.<br/>
                <code>setTimeout</code> ne bloque pas l'éxécution du code, donc <code>i</code> vaut toujours 0 au moment où est éxécuté <code>console.log</code>
                </reponse>
    		</qcm>

    		<qcm>
    			<code>let i=0;

setTimeout(() => console.log(i), 1000);

i++;</code>
    			<question>la console affichera</question>
    			<choix>0</choix>
    			<choix correct>1</choix>
                <code>La fonction éxécutée avec une seconde de délai prendra la valeur de <code>i</code> telle qu'elle est à cet instant.</code>
    		</qcm>

    		<qcm>
    			<code>let i=0;

function delai() {
	setTimeout(() => i++, 1000);
}

delai();
delai();
</code>
    			<question>Après 1.5s, i vaut</question>
    			<choix>0</choix>
    			<choix>1</choix>
    			<choix correct>2</choix>
                <reponse>La fonction <code>delai</code> est lancée deux fois deux suite. L'incrémentation se fera donc deux fois deux suite, une seconde plus tard.</reponse>
    		</qcm>
